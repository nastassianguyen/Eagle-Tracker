{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/nastassianguyen/Desktop/proj/EagleTracker/src/ViewAll.tsx\",\n    _s = $RefreshSig$();\n\n/* \nfile: Map.tsx \n    file for the map display of the most recent locations of devices\n    will need to implement google maps API in this component \n*/\nimport React, { useEffect } from 'react';\nimport './App.css';\nimport { DeviceApi, UserApi } from \"./lb-api\";\nimport { Configuration } from \"./lb-api/configuration\";\nimport Geocode from \"react-geocode\";\nimport Map from './Map'; // interface for device object\n\nexport default function ViewAll() {\n  _s();\n\n  // react hooks maintaining center, devices, and selected \n  const [center, setCenter] = React.useState({\n    // state to re-render\n    lat: 0,\n    lng: 0\n  });\n  const [devices, setDevices] = React.useState([]); // for hooks \n\n  useEffect(() => {\n    getDevicesAndPoints();\n  }, []); // for reverse geocoding to get city/state/country\n\n  Geocode.setApiKey(process.env.REACT_APP_GOOGLE_MAPS_API_KEY); // function for getting the city/state/country \n\n  const getCityState = async point => {\n    let city = \"\",\n        state = \"\",\n        country = \"\";\n    const response = await Geocode.fromLatLng(String(point.lat), String(point.lng));\n    let parts = response.results[0].address_components;\n    parts.forEach(part => {\n      if (part.types.includes(\"locality\")) {\n        city = part.long_name;\n      } else if (part.types.includes(\"administrative_area_level_1\")) {\n        state = part.long_name;\n      } else if (part.types.includes(\"country\")) {\n        country = part.long_name;\n      } else {// do nothing\n      }\n    });\n    return [city, state, country];\n  }; // get the devices and most recent point\n\n\n  const getDevicesAndPoints = async () => {\n    try {\n      const config = new Configuration();\n      const userApi = new UserApi(config);\n      const deviceApi = new DeviceApi(config);\n\n      try {\n        let token = await userApi.userLogin({\n          username: process.env.REACT_APP_LIGHTBUG_API_USERNAME,\n          password: process.env.REACT_APP_LIGHTBUG_API_PASSWORD\n        });\n        config.accessToken = token.id;\n        config.userId = `${token.userId}`;\n      } catch {\n        console.error('Login Failed');\n        alert('Login Fail');\n        return;\n      }\n\n      let allDevices = await userApi.userPrototypeGetDevices(config.userId, JSON.stringify({\n        where: {\n          lastConnection: {\n            gt: +new Date() - 7 * 24 * 3600 * 1000\n          }\n        }\n      }));\n      const locations = [];\n\n      for (const device of allDevices) {\n        var _points$0$location, _points$0$location2;\n\n        if (!device.id) continue; // prevent error on next line\n\n        let points = await deviceApi.devicePrototypeGetPoints(device.id, JSON.stringify({\n          where: {\n            timestamp: {\n              between: [+new Date() - 7 * 24 * 3600 * 1000, new Date()]\n            },\n            locationType: {\n              neq: 'invalid'\n            }\n          },\n          order: 'timestamp DESC',\n          // order by newest points first\n          limit: 1\n        })); // getting city/state/location\n\n        let where = await getCityState(points[0].location); // push to array\n\n        locations.push({\n          name: device.name,\n          id: device.id,\n          lat: (_points$0$location = points[0].location) === null || _points$0$location === void 0 ? void 0 : _points$0$location.lat,\n          lng: (_points$0$location2 = points[0].location) === null || _points$0$location2 === void 0 ? void 0 : _points$0$location2.lng,\n          time: points[0].timestamp,\n          city: where[0],\n          state: where[1],\n          country: where[2]\n        });\n      }\n\n      setDevices(locations); // get center of map based on most recent locations\n\n      let lat_sum = 0;\n      let lng_sum = 0;\n\n      for (let item of locations) {\n        lat_sum += item.lat;\n        lng_sum += item.lng;\n      }\n\n      const new_center = {\n        lat: lat_sum / locations.length,\n        lng: lng_sum / locations.length\n      };\n      setCenter(new_center);\n    } catch (e) {\n      console.error(\"Failed to get data\", e);\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    className: \"responsive-margin\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"card fluid\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"section\",\n        children: /*#__PURE__*/_jsxDEV(\"h1\", {\n          children: \"View All\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 137,\n          columnNumber: 17\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 136,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"section double-padded\",\n        children: /*#__PURE__*/_jsxDEV(Map, {\n          devices: devices,\n          center: center,\n          displayAll: true\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 140,\n          columnNumber: 21\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 139,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 134,\n    columnNumber: 9\n  }, this);\n}\n\n_s(ViewAll, \"Np1aMjReUmKoz317Ck4LUQPF1j0=\");\n\n_c = ViewAll;\n\nvar _c;\n\n$RefreshReg$(_c, \"ViewAll\");","map":{"version":3,"sources":["/Users/nastassianguyen/Desktop/proj/EagleTracker/src/ViewAll.tsx"],"names":["React","useEffect","DeviceApi","UserApi","Configuration","Geocode","Map","ViewAll","center","setCenter","useState","lat","lng","devices","setDevices","getDevicesAndPoints","setApiKey","process","env","REACT_APP_GOOGLE_MAPS_API_KEY","getCityState","point","city","state","country","response","fromLatLng","String","parts","results","address_components","forEach","part","types","includes","long_name","config","userApi","deviceApi","token","userLogin","username","REACT_APP_LIGHTBUG_API_USERNAME","password","REACT_APP_LIGHTBUG_API_PASSWORD","accessToken","id","userId","console","error","alert","allDevices","userPrototypeGetDevices","JSON","stringify","where","lastConnection","gt","Date","locations","device","points","devicePrototypeGetPoints","timestamp","between","locationType","neq","order","limit","location","push","name","time","lat_sum","lng_sum","item","new_center","length","e"],"mappings":"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","sourcesContent":["/* \nfile: Map.tsx \n    file for the map display of the most recent locations of devices\n    will need to implement google maps API in this component \n*/\n\nimport React, {useEffect} from 'react';\nimport './App.css';\nimport {DeviceApi, UserApi} from \"./lb-api\";\nimport {Configuration} from \"./lb-api/configuration\";\nimport Geocode from \"react-geocode\";\n\nimport Map from './Map';\n\n\n// interface for device object\nexport interface Device {\n    name: string;\n    id: number;\n    lat: number;\n    lng: number;\n    time: Date;\n    city: string;\n    state: string;\n    country: string;\n}\n\nexport default function ViewAll() {\n    // react hooks maintaining center, devices, and selected \n    const [center, setCenter] = React.useState({ // state to re-render\n        lat: 0,\n        lng: 0,\n    });\n    \n    const [devices, setDevices] = React.useState<Device[]>([]);\n\n    // for hooks \n    useEffect(() => {\n        getDevicesAndPoints();\n    }, []);\n\n    // for reverse geocoding to get city/state/country\n    Geocode.setApiKey(process.env.REACT_APP_GOOGLE_MAPS_API_KEY);\n\n    // function for getting the city/state/country \n    const getCityState = async (point) => {\n        let city = \"\", state = \"\", country = \"\";\n        const response = await Geocode.fromLatLng(String(point.lat), String(point.lng));\n        let parts = response.results[0].address_components;\n        parts.forEach(part => {\n            if (part.types.includes(\"locality\")) {\n                city = part.long_name;\n            } else if (part.types.includes(\"administrative_area_level_1\")) {\n                state = part.long_name;\n            } else if (part.types.includes(\"country\")) {\n                country = part.long_name;\n            } else {\n                // do nothing\n            }\n        })\n        return [city, state, country];\n    }\n\n    // get the devices and most recent point\n    const getDevicesAndPoints = async () => {\n        try {\n            const config = new Configuration();\n            const userApi = new UserApi(config);\n            const deviceApi = new DeviceApi(config);\n            try {\n                let token = await userApi.userLogin({username: process.env.REACT_APP_LIGHTBUG_API_USERNAME, password: process.env.REACT_APP_LIGHTBUG_API_PASSWORD});\n                config.accessToken = token.id;\n                config.userId = `${token.userId}`;\n            } catch {\n                console.error('Login Failed')\n                alert('Login Fail');\n                return;\n            }\n\n            let allDevices = await userApi.userPrototypeGetDevices(config.userId,\n                JSON.stringify({where: {lastConnection : {gt: +new Date() - 7 * 24 * 3600 * 1000} }})\n            );\n\n            const locations: any[] = [];\n            for (const device of allDevices) {\n                if (!device.id) continue; // prevent error on next line\n                let points = await deviceApi.devicePrototypeGetPoints(device.id,\n                    JSON.stringify({\n                        where: {\n                            timestamp: {between: [+new Date() - 7 * 24 * 3600 * 1000, new Date()]},\n                            locationType: {neq: 'invalid'}\n                        },\n                        order: 'timestamp DESC', // order by newest points first\n                        limit: 1,\n                    }));\n\n                // getting city/state/location\n                let where = await getCityState(points[0].location);\n\n                // push to array\n                locations.push(\n                    {\n                        name: device.name,\n                        id: device.id,\n                        lat: points[0].location?.lat,\n                        lng: points[0].location?.lng,\n                        time: points[0].timestamp,\n                        city: where[0],\n                        state: where[1],\n                        country: where[2],\n                    }\n                )\n                \n            }\n            setDevices(locations);\n            // get center of map based on most recent locations\n            let lat_sum = 0;\n            let lng_sum = 0;\n            for (let item of locations) {\n                lat_sum += item.lat; \n                lng_sum += item.lng;\n            }\n            const new_center = {\n                lat: lat_sum / locations.length,\n                lng: lng_sum / locations.length\n            };\n            setCenter(new_center);\n        } catch (e) {\n            console.error(\"Failed to get data\", e);\n        }\n    }\n\n    return (\n        <span className= \"responsive-margin\">\n            <div className=\"card fluid\">\n                <div className=\"section\">\n                <h1>View All</h1>\n                </div>\n                <div className=\"section double-padded\">\n                    <Map devices={devices} center={center} displayAll={true} />\n                </div>\n            </div>\n        </span>\n    );\n}"]},"metadata":{},"sourceType":"module"}