/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * TrackingAPI
 * API for retrieving tracking data and changing settings on LightBug & RemoteThings tracking devices
 *
 * OpenAPI spec version: 1.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import {Configuration} from "./configuration";

const BASE_PATH = "https://api.thelightbug.com/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"

    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     *
     * @type {string}
     * @memberof AccessToken
     */
    id: string;
    /**
     * time to live in seconds (2 weeks by default)
     * @type {number}
     * @memberof AccessToken
     */
    ttl?: number;
    /**
     * Array of scopes granted to this access token.
     * @type {Array<string>}
     * @memberof AccessToken
     */
    scopes?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof AccessToken
     */
    created?: Date;
    /**
     *
     * @type {number}
     * @memberof AccessToken
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     *
     * @type {string}
     * @memberof Credentials
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof Credentials
     */
    password?: string;
}

/**
 *
 * @export
 * @interface Datapoint
 */
export interface Datapoint {
    /**
     *
     * @type {GeoPoint}
     * @memberof Datapoint
     */
    location?: GeoPoint;
    /**
     * Timestamp for the datapoint. NB this is not necessarily the same as 'created'
     * @type {Date}
     * @memberof Datapoint
     */
    timestamp: Date;
    /**
     * Ground velocity in kmh, as determined by the GPS
     * @type {number}
     * @memberof Datapoint
     */
    speed?: number;
    /**
     * Altitude in m, as determined by the GPS
     * @type {number}
     * @memberof Datapoint
     */
    altitude?: number;
    /**
     * Course in degrees, as determined by the GPS
     * @type {number}
     * @memberof Datapoint
     */
    course?: number;
    /**
     * Internal use only
     * @type {string}
     * @memberof Datapoint
     */
    numValue?: string;
    /**
     * Internal use only
     * @type {string}
     * @memberof Datapoint
     */
    stringValue?: string;
    /**
     * Bitfield indicating reason for datapoint transmission and status of the device at the time.   Bit1(1): Wake mode active,    Bit2(2): Sleep mode active,    Bit3(4): Bluetooth disconnected,    Bit4(8): Outside of Safe-zone,    Bit5(16): Motion detected,    Bit6(32): Device started moving,    Bit7(64): Device stopped moving,    Bit8(128): Position is stale: last known location was used   Special case 255/0xFF: device was checking in with server. Ignore all data
     * @type {number}
     * @memberof Datapoint
     */
    sendReason?: number;
    /**
     * Number of visible satellites, as determined by the GPS
     * @type {number}
     * @memberof Datapoint
     */
    sats?: number;
    /**
     * Deprecated
     * @type {number}
     * @memberof Datapoint
     */
    hdop?: number;
    /**
     * Accuracy of the location in meters
     * @type {number}
     * @memberof Datapoint
     */
    accuracy?: number;
    /**
     * Type of position. Can be 'gps', 'wifi', 'gsm' or 'invalid'
     * @type {string}
     * @memberof Datapoint
     */
    locationType: string;
    /**
     * Battery charge level in volts.
     * @type {number}
     * @memberof Datapoint
     */
    batteryVoltage?: number;
    /**
     * Internal Use. 255 indicates plugged in and charging.
     * @type {number}
     * @memberof Datapoint
     */
    averageCharge?: number;
    /**
     * Timestamp for when the datapoint was received and processed by the server
     * @type {Date}
     * @memberof Datapoint
     */
    created: Date;
    /**
     * A reverse geocode result for the point
     * @type {string}
     * @memberof Datapoint
     */
    address?: string;
    /**
     * Bitfield indicating what alerts where active at transmission time   Bit1(1): Freefall / Drop detected,    Bit2(2): Rotation detected,    Bit3(4): GSM jamming detected,    Bit4(8): Button was pressed,    Bit5(16): Generic Alert
     * @type {number}
     * @memberof Datapoint
     */
    alertType?: number;
    /**
     * Current Used to send this location in microAmp Hours
     * @type {number}
     * @memberof Datapoint
     */
    currentUsed?: number;
    /**
     * GSM CSQ value
     * @type {number}
     * @memberof Datapoint
     */
    gsmSignal?: number;
    /**
     * Internal use - correlation identifier
     * @type {string}
     * @memberof Datapoint
     */
    correlationId?: string;
    /**
     *
     * @type {number}
     * @memberof Datapoint
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof Datapoint
     */
    deviceId?: number;
}

/**
 *
 * @export
 * @interface Device
 */
export interface Device {
    /**
     *
     * @type {string}
     * @memberof Device
     */
    imei?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    iccid?: string;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    loraId?: number;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    imsi?: string;
    /**
     * Bluetooth MAC Address as 48bit number
     * @type {number}
     * @memberof Device
     */
    btMac?: number;
    /**
     * Bluetooth MAC Address in standard format
     * @type {string}
     * @memberof Device
     */
    btMacAddress?: string;
    /**
     * UWB Address as 32bit number
     * @type {number}
     * @memberof Device
     */
    uwbId?: number;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    serial?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    type?: string;
    /**
     *
     * @type {Date}
     * @memberof Device
     */
    expires?: Date;
    /**
     *
     * @type {Date}
     * @memberof Device
     */
    lastConnection?: Date;
    /**
     *
     * @type {Date}
     * @memberof Device
     */
    firstSeen: Date;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    mode?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    batteryVoltage?: number;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    batteryType?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Device
     */
    tags?: Array<string>;
    /**
     * Indicates last known device state. 0 = awake, 1 = sleep, 6 = flight mode
     * @type {number}
     * @memberof Device
     */
    currentMode?: number;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    color?: string;
    /**
     *
     * @type {boolean}
     * @memberof Device
     */
    saveToWeb?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Device
     */
    active?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Device
     */
    deepSleep?: boolean;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    simstate?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    stripeSubscription?: string;
    /**
     *
     * @type {string}
     * @memberof Device
     */
    subscriptionType?: string;
    /**
     *
     * @type {any}
     * @memberof Device
     */
    meta?: any;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    resellerId?: number;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    resellerPlanId?: number;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    ownerId?: number;
    /**
     *
     * @type {number}
     * @memberof Device
     */
    securePhoneId?: number;
}

/**
 *
 * @export
 * @interface DeviceConfig
 */
export interface DeviceConfig {
    /**
     * Current Firmware version
     * @type {string}
     * @memberof DeviceConfig
     */
    currentFW?: string;
    /**
     * Pending Firmware version. If non null, the unit will be told to upgrade to this version when it next transmits in sleep mode.
     * @type {string}
     * @memberof DeviceConfig
     */
    otaFW?: string;
    /**
     * The wake mode interval in seconds. The unit will connect to the server this often when awake.
     * @type {number}
     * @memberof DeviceConfig
     */
    interval: number;
    /**
     * Sleep mode interval in seconds. The unit will try to connect this often to the server when asleep
     * @type {number}
     * @memberof DeviceConfig
     */
    sleepInterval: number;
    /**
     * DEPRECATED A failsafe to ensure the unit connects to the server at least this often.
     * @type {number}
     * @memberof DeviceConfig
     */
    checkInInterval?: number;
    /**
     * The number of GPS points to send with each transmission. A packing setting of 3 with an 'interval' of 60s will result in points recorded approximately every 20s, but they will only be sent together. This increases the time you have to wait for locations to come through to the server but improves battery life
     * @type {number}
     * @memberof DeviceConfig
     */
    packing: number;
    /**
     * Deprecated. See debounce.
     * @type {number}
     * @memberof DeviceConfig
     */
    movementSensitivity?: number;
    /**
     * Movement sensitivity on a scale of 1 to 10, with 1 being the most sensitive. It is correlated to the number of consecutive milliseconds the acceleration needs to exceed the movementSensitivity threshold
     * @type {number}
     * @memberof DeviceConfig
     */
    debounce?: number;
    /**
     * A secondary debounce value. Typically this value is lower or equal to debounce, representing increased sensitivity to movement once the device is already moving.
     * @type {number}
     * @memberof DeviceConfig
     */
    movementSensitivity2?: number;
    /**
     * Char Bitfield with various flags. Advanced use only.  DisableBluetooth:32 |  Encrypt:128 |  GsmOnWhenAwake:1 |  GsmOnWhenAsleep:2 |  GpsOnWhenAwake:4 |  DisableWifiAccuracyAssist:8 |  RepeatSleep:16 |  DisableWifi:64
     * @type {number}
     * @memberof DeviceConfig
     */
    behavior?: number;
    /**
     * Char Bitfield with various flags. Advanced use only.  StartStopOnly:1 |  LockAwakeOnAlert:2 |  SendSleepLocAfterBtDisconnect:4 |
     * @type {number}
     * @memberof DeviceConfig
     */
    modeControl?: number;
    /**
     * Char Bitfield with various flags. Advanced use only. FW >= 69.  SendStopImmediately:1 |  StopTimeoutIsInMinutes:2 |  HarshPowerBudget:4 |  Lock2G: 8
     * @type {number}
     * @memberof DeviceConfig
     */
    modeControl2?: number;
    /**
     * How long to let the GPS searches for a lock in seconds before giving up. Max 255s.
     * @type {number}
     * @memberof DeviceConfig
     */
    gpsTimeout?: number;
    /**
     * When the unit first wakes up from sleep, how long to wait before trying to transmit in multiples of 30 seconds. 0 = instant, 1 = 30s, 2 = 60s...   Useful to avoid detection or draining battery inside shielded buildings.
     * @type {number}
     * @memberof DeviceConfig
     */
    transmitTimeout?: number;
    /**
     * How long to let the GPS stabilise in seconds once a lock is achieved before sending the position. Higher values may increase accuracy.
     * @type {number}
     * @memberof DeviceConfig
     */
    gpsStabilize?: number;
    /**
     * If a safe-zone is used, how often to check the wifi & gps to see if its still inside it (only applies when motion is detected)
     * @type {number}
     * @memberof DeviceConfig
     */
    gpsCheckInterval?: number;
    /**
     * The total amount of time in seconds the unit has to be stationary for before deeming the journey over and switching to sleep mode
     * @type {number}
     * @memberof DeviceConfig
     */
    stopTimeout?: number;
    /**
     * Power budget in mAh per location update. Default 10, do not set lower than 5.
     * @type {number}
     * @memberof DeviceConfig
     */
    tolerancePercentage?: number;
    /**
     *
     * @type {Array<any>}
     * @memberof DeviceConfig
     */
    reasonsToWake?: Array<any>;
    /**
     * Set to any non null date to indicate the configuration should be pushed to the device when it next connects
     * @type {Date}
     * @memberof DeviceConfig
     */
    modified?: Date;
    /**
     * Internal use.   Used with otaFW. Set to true to force the unit to upgrade on next connection (rather than waiting for a sleep connection
     * @type {boolean}
     * @memberof DeviceConfig
     */
    forceFw?: boolean;
    /**
     * Indicates the last time the settings were sent to the device
     * @type {Date}
     * @memberof DeviceConfig
     */
    receivedAt?: Date;
    /**
     * Non NULL values cause unit to restart on next connection   0 = Normal reboot   1 = Clear settings cache and restart   2 = Clear cache and bluetooth connection data, then restart
     * @type {number}
     * @memberof DeviceConfig
     */
    reset?: number;
    /**
     * Internal use. Set to 0 when changing otaFW
     * @type {number}
     * @memberof DeviceConfig
     */
    flashTryCount?: number;
    /**
     * WiFi network name to use as a Safe-zone. When this network is visible, stay asleep
     * @type {string}
     * @memberof DeviceConfig
     */
    homeWifiNetwork?: string;
    /**
     * WiFi network paswword. If set enables transmission over WiFi.
     * @type {string}
     * @memberof DeviceConfig
     */
    homeWifiPassword?: string;
    /**
     * Internal Use Only. What to do when the unit wakes up (ie is moved and not in a safe-zone). Options are 'available' (lost and found), and 'normal' (tracking)
     * @type {string}
     * @memberof DeviceConfig
     */
    wakeAction: string;
    /**
     * Deprecated
     * @type {number}
     * @memberof DeviceConfig
     */
    onDemandTime: number;
    /**
     * What to do when the button is pressed or the unit is dropped. Options are 'available' (stay registered on the mobile network), 'nothing' (one transmission) and  'lockOn' (keep transmitting at 'interval' until instructed otherwise
     * @type {string}
     * @memberof DeviceConfig
     */
    alertAction: string;
    /**
     *
     * @type {number}
     * @memberof DeviceConfig
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceConfig
     */
    deviceId?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceConfig
     */
    safeZoneId?: number;
}

/**
 *
 * @export
 * @interface DeviceMessage
 */
export interface DeviceMessage {
    /**
     *
     * @type {string}
     * @memberof DeviceMessage
     */
    config?: string;
    /**
     *
     * @type {string}
     * @memberof DeviceMessage
     */
    message?: string;
    /**
     *
     * @type {boolean}
     * @memberof DeviceMessage
     */
    mobileTerminated?: boolean;
    /**
     *
     * @type {Date}
     * @memberof DeviceMessage
     */
    created: Date;
    /**
     *
     * @type {Date}
     * @memberof DeviceMessage
     */
    sent?: Date;
    /**
     *
     * @type {number}
     * @memberof DeviceMessage
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceMessage
     */
    deviceId?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceMessage
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface DeviceTransient
 */
export interface DeviceTransient {
    /**
     *
     * @type {number}
     * @memberof DeviceTransient
     */
    type: number;
    /**
     *
     * @type {number}
     * @memberof DeviceTransient
     */
    duration: number;
    /**
     *
     * @type {Date}
     * @memberof DeviceTransient
     */
    triggeredAt: Date;
    /**
     *
     * @type {Date}
     * @memberof DeviceTransient
     */
    end?: Date;
    /**
     *
     * @type {Date}
     * @memberof DeviceTransient
     */
    sent?: Date;
    /**
     *
     * @type {boolean}
     * @memberof DeviceTransient
     */
    sms?: boolean;
    /**
     *
     * @type {number}
     * @memberof DeviceTransient
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof DeviceTransient
     */
    deviceId?: number;
}

/**
 *
 * @export
 * @interface GeoPoint
 */
export interface GeoPoint {
    /**
     *
     * @type {number}
     * @memberof GeoPoint
     */
    lat?: number;
    /**
     *
     * @type {number}
     * @memberof GeoPoint
     */
    lng?: number;
}

/**
 *
 * @export
 * @interface Geofence
 */
export interface Geofence {
    /**
     * Array of {lat:x,lng:y} objects representing the vertices of the polygon. Do not use with center and radius.
     * @type {Array<any>}
     * @memberof Geofence
     */
    outline?: Array<any>;
    /**
     * For circular geofences, the center. Property is ignored if outline != null.
     * @type {GeoPoint}
     * @memberof Geofence
     */
    center?: GeoPoint;
    /**
     * For circular geofences, the radius of the circle in meters. Property is ignored if outline != null.
     * @type {number}
     * @memberof Geofence
     */
    radius?: number;
    /**
     * Grouping value
     * @type {string}
     * @memberof Geofence
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof Geofence
     */
    name?: string;
    /**
     * If the last point received was inside the geofence. Only updated for notifications (not the safe-zone as that is evaluated on the device)
     * @type {boolean}
     * @memberof Geofence
     */
    wasInside?: boolean;
    /**
     * When the geofence was last evaluated. Only updated for notifications (not the safe-zone as that is evaluated on the device)
     * @type {Date}
     * @memberof Geofence
     */
    lastChecked?: Date;
    /**
     *
     * @type {boolean}
     * @memberof Geofence
     */
    modified?: boolean;
    /**
     *
     * @type {number}
     * @memberof Geofence
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof Geofence
     */
    deviceId?: number;
    /**
     *
     * @type {number}
     * @memberof Geofence
     */
    configId?: number;
    /**
     *
     * @type {number}
     * @memberof Geofence
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    clientId?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    password?: string;
}

/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     *
     * @type {Date}
     * @memberof Notification
     */
    created: Date;
    /**
     *
     * @type {any}
     * @memberof Notification
     */
    params?: any;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    message?: string;
    /**
     *
     * @type {Date}
     * @memberof Notification
     */
    dismissedOn?: Date;
    /**
     *
     * @type {any}
     * @memberof Notification
     */
    dismissedBy?: any;
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    deviceId?: number;
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    pointId?: number;
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    userId?: number;
    /**
     *
     * @type {number}
     * @memberof Notification
     */
    triggerId?: number;
}

/**
 *
 * @export
 * @interface NotificationTrigger
 */
export interface NotificationTrigger {
    /**
     *
     * @type {string}
     * @memberof NotificationTrigger
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof NotificationTrigger
     */
    type: string;
    /**
     *
     * @type {any}
     * @memberof NotificationTrigger
     */
    parameters?: any;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    muteFor: number;
    /**
     *
     * @type {Date}
     * @memberof NotificationTrigger
     */
    lastTriggered?: Date;
    /**
     *
     * @type {any}
     * @memberof NotificationTrigger
     */
    delivery: any;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    userListId?: number;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    deviceListId?: number;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    deviceId?: number;
    /**
     *
     * @type {number}
     * @memberof NotificationTrigger
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface SensorReading
 */
export interface SensorReading {
    /**
     * Timestamp for the reading
     * @type {Date}
     * @memberof SensorReading
     */
    timestamp: Date;
    /**
     * Timestamp for the writing to db
     * @type {Date}
     * @memberof SensorReading
     */
    created: Date;
    /**
     * Sensor type: 'ultra' (fill level), 'temp' (temperature), ...
     * @type {string}
     * @memberof SensorReading
     */
    type: string;
    /**
     * JSON value
     * @type {any}
     * @memberof SensorReading
     */
    value: any;
    /**
     * RSSI if from secondary wireless device
     * @type {number}
     * @memberof SensorReading
     */
    rssi?: number;
    /**
     * JSON metadata
     * @type {any}
     * @memberof SensorReading
     */
    meta?: any;
    /**
     * LoraId of another (ie for signal strength)
     * @type {number}
     * @memberof SensorReading
     */
    relatedId?: number;
    /**
     * Internal use - correlation identifier
     * @type {string}
     * @memberof SensorReading
     */
    correlationId?: string;
    /**
     *
     * @type {number}
     * @memberof SensorReading
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof SensorReading
     */
    gatewayId?: number;
    /**
     *
     * @type {number}
     * @memberof SensorReading
     */
    deviceId?: number;
    /**
     *
     * @type {string}
     * @memberof SensorReading
     */
    sensorDeviceId?: string;
    /**
     *
     * @type {number}
     * @memberof SensorReading
     */
    datapointId?: number;
}


/**
 * DeviceApi - fetch parameter creator
 * @export
 */
export const DeviceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFindById(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deviceFindById.');
            }
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new instance in gatewayReadings of this model.
         * @param {number} id device id
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateGatewayReadings(id: number, data?: SensorReading, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeCreateGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SensorReading" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new instance in messages of this model.
         * @param {number} id device id
         * @param {DeviceMessage} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateMessages(id: number, data?: DeviceMessage, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeCreateMessages.');
            }
            const localVarPath = `/devices/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create alert/notification trigger for device
         * @param {number} id device id
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateNotificationTriggers(id: number, data?: NotificationTrigger, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeCreateNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NotificationTrigger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes all gatewayReadings of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteGatewayReadings(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDeleteGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes all messages of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteMessages(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDeleteMessages.');
            }
            const localVarPath = `/devices/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove all alert/notification trigger for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteNotificationTriggers(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDeleteNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdGatewayReadings(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDestroyByIdGatewayReadings.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeDestroyByIdGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdNotificationTriggers(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDestroyByIdNotificationTriggers.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeDestroyByIdNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdPoints(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDestroyByIdPoints.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeDestroyByIdPoints.');
            }
            const localVarPath = `/devices/{id}/points/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdTransients(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeDestroyByIdTransients.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeDestroyByIdTransients.');
            }
            const localVarPath = `/devices/{id}/transients/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdGatewayReadings(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFindByIdGatewayReadings.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeFindByIdGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a related item by id for notificationTriggers.
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdNotificationTriggers(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFindByIdNotificationTriggers.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeFindByIdNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdPoints(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFindByIdPoints.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeFindByIdPoints.');
            }
            const localVarPath = `/devices/{id}/points/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a specific reading for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for readings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdReadings(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFindByIdReadings.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeFindByIdReadings.');
            }
            const localVarPath = `/devices/{id}/readings/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdTransients(id: number, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFindByIdTransients.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeFindByIdTransients.');
            }
            const localVarPath = `/devices/{id}/transients/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {number} duration How long to go into flightMode, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFlightMode(id: number, duration: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeFlightMode.');
            }
            // verify required parameter 'duration' is not null or undefined
            if (duration === null || duration === undefined) {
                throw new RequiredError('duration', 'Required parameter duration was null or undefined when calling devicePrototypeFlightMode.');
            }
            const localVarPath = `/devices/{id}/flightMode`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve configuration for a device
         * @param {number} id device id
         * @param {boolean} [refresh] unused
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetConfig(id: number, refresh?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetConfig.');
            }
            const localVarPath = `/devices/{id}/config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Queries gatewayReadings of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetGatewayReadings(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Queries messages of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetMessages(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetMessages.');
            }
            const localVarPath = `/devices/{id}/messages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get alerts for device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetNotificationTriggers(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve points for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetPoints(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetPoints.');
            }
            const localVarPath = `/devices/{id}/points`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve readings for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetReadings(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetReadings.');
            }
            const localVarPath = `/devices/{id}/readings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get safe-zone for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetSafeZone(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetSafeZone.');
            }
            const localVarPath = `/devices/{id}/getSafeZone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Queries transients of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetTransients(id: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeGetTransients.');
            }
            const localVarPath = `/devices/{id}/transients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {string} nearbyId
         * @param {string} dateRange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDeviceData(id: number, nearbyId: string, dateRange: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeNearbyDeviceData.');
            }
            // verify required parameter 'nearbyId' is not null or undefined
            if (nearbyId === null || nearbyId === undefined) {
                throw new RequiredError('nearbyId', 'Required parameter nearbyId was null or undefined when calling devicePrototypeNearbyDeviceData.');
            }
            // verify required parameter 'dateRange' is not null or undefined
            if (dateRange === null || dateRange === undefined) {
                throw new RequiredError('dateRange', 'Required parameter dateRange was null or undefined when calling devicePrototypeNearbyDeviceData.');
            }
            const localVarPath = `/devices/{id}/nearbyDeviceData`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (nearbyId !== undefined) {
                localVarQueryParameter['nearbyId'] = nearbyId;
            }

            if (dateRange !== undefined) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {string} [dateRange]
         * @param {string} [correlationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDevices(id: number, dateRange?: string, correlationId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeNearbyDevices.');
            }
            const localVarPath = `/devices/{id}/nearbyDevices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (dateRange !== undefined) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (correlationId !== undefined) {
                localVarQueryParameter['correlationId'] = correlationId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update safe-zone for device
         * @param {number} id device id
         * @param {Array<GeoPoint>} data Array of {lat:x,lng:y} points denoting the vertices of the safe-zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeSetSafeZone(id: number, data: Array<GeoPoint>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeSetSafeZone.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data', 'Required parameter data was null or undefined when calling devicePrototypeSetSafeZone.');
            }
            const localVarPath = `/devices/{id}/setSafeZone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;GeoPoint&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdGatewayReadings(id: number, fk: number, data?: SensorReading, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeUpdateByIdGatewayReadings.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeUpdateByIdGatewayReadings.');
            }
            const localVarPath = `/devices/{id}/gatewayReadings/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SensorReading" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdNotificationTriggers(id: number, fk: number, data?: NotificationTrigger, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeUpdateByIdNotificationTriggers.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeUpdateByIdNotificationTriggers.');
            }
            const localVarPath = `/devices/{id}/notificationTriggers/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NotificationTrigger" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {DeviceTransient} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdTransients(id: number, fk: number, data?: DeviceTransient, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeUpdateByIdTransients.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling devicePrototypeUpdateByIdTransients.');
            }
            const localVarPath = `/devices/{id}/transients/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceTransient" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update configuration for a device
         * @param {number} id device id
         * @param {DeviceConfig} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateConfig(id: number, data?: DeviceConfig, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling devicePrototypeUpdateConfig.');
            }
            const localVarPath = `/devices/{id}/config`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFindById(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Device> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).deviceFindById(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new instance in gatewayReadings of this model.
         * @param {number} id device id
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateGatewayReadings(id: number, data?: SensorReading, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SensorReading> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeCreateGatewayReadings(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new instance in messages of this model.
         * @param {number} id device id
         * @param {DeviceMessage} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateMessages(id: number, data?: DeviceMessage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceMessage> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeCreateMessages(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create alert/notification trigger for device
         * @param {number} id device id
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateNotificationTriggers(id: number, data?: NotificationTrigger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTrigger> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeCreateNotificationTriggers(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Deletes all gatewayReadings of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteGatewayReadings(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDeleteGatewayReadings(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Deletes all messages of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteMessages(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDeleteMessages(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove all alert/notification trigger for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteNotificationTriggers(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDeleteNotificationTriggers(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdGatewayReadings(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDestroyByIdGatewayReadings(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdNotificationTriggers(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDestroyByIdNotificationTriggers(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdPoints(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDestroyByIdPoints(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdTransients(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeDestroyByIdTransients(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdGatewayReadings(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SensorReading> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFindByIdGatewayReadings(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a related item by id for notificationTriggers.
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdNotificationTriggers(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTrigger> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFindByIdNotificationTriggers(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdPoints(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Datapoint> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFindByIdPoints(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve a specific reading for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for readings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdReadings(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SensorReading> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFindByIdReadings(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdTransients(id: number, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceTransient> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFindByIdTransients(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {number} duration How long to go into flightMode, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFlightMode(id: number, duration: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeFlightMode(id, duration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve configuration for a device
         * @param {number} id device id
         * @param {boolean} [refresh] unused
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetConfig(id: number, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceConfig> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetConfig(id, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Queries gatewayReadings of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetGatewayReadings(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SensorReading>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetGatewayReadings(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Queries messages of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetMessages(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceMessage>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetMessages(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get alerts for device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetNotificationTriggers(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotificationTrigger>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetNotificationTriggers(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve points for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetPoints(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Datapoint>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetPoints(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve readings for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetReadings(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SensorReading>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetReadings(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get safe-zone for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetSafeZone(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Geofence> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetSafeZone(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Queries transients of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetTransients(id: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTransient>> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeGetTransients(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {string} nearbyId
         * @param {string} dateRange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDeviceData(id: number, nearbyId: string, dateRange: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeNearbyDeviceData(id, nearbyId, dateRange, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} id device id
         * @param {string} [dateRange]
         * @param {string} [correlationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDevices(id: number, dateRange?: string, correlationId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeNearbyDevices(id, dateRange, correlationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update safe-zone for device
         * @param {number} id device id
         * @param {Array<GeoPoint>} data Array of {lat:x,lng:y} points denoting the vertices of the safe-zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeSetSafeZone(id: number, data: Array<GeoPoint>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Geofence> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeSetSafeZone(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdGatewayReadings(id: number, fk: number, data?: SensorReading, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SensorReading> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeUpdateByIdGatewayReadings(id, fk, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdNotificationTriggers(id: number, fk: number, data?: NotificationTrigger, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationTrigger> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeUpdateByIdNotificationTriggers(id, fk, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {DeviceTransient} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdTransients(id: number, fk: number, data?: DeviceTransient, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceTransient> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeUpdateByIdTransients(id, fk, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update configuration for a device
         * @param {number} id device id
         * @param {DeviceConfig} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateConfig(id: number, data?: DeviceConfig, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceConfig> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).devicePrototypeUpdateConfig(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param {string} id Model id
         * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFindById(id: string, filter?: string, options?: any) {
            return DeviceApiFp(configuration).deviceFindById(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in gatewayReadings of this model.
         * @param {number} id device id
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateGatewayReadings(id: number, data?: SensorReading, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeCreateGatewayReadings(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in messages of this model.
         * @param {number} id device id
         * @param {DeviceMessage} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateMessages(id: number, data?: DeviceMessage, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeCreateMessages(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create alert/notification trigger for device
         * @param {number} id device id
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeCreateNotificationTriggers(id: number, data?: NotificationTrigger, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeCreateNotificationTriggers(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all gatewayReadings of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteGatewayReadings(id: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDeleteGatewayReadings(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all messages of this model.
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteMessages(id: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDeleteMessages(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove all alert/notification trigger for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDeleteNotificationTriggers(id: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDeleteNotificationTriggers(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdGatewayReadings(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDestroyByIdGatewayReadings(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdNotificationTriggers(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDestroyByIdNotificationTriggers(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdPoints(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDestroyByIdPoints(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeDestroyByIdTransients(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeDestroyByIdTransients(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdGatewayReadings(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFindByIdGatewayReadings(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for notificationTriggers.
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdNotificationTriggers(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFindByIdNotificationTriggers(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve a specific point for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdPoints(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFindByIdPoints(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve a specific reading for a device
         * @param {number} id device id
         * @param {number} fk Foreign key for readings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdReadings(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFindByIdReadings(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFindByIdTransients(id: number, fk: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFindByIdTransients(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id device id
         * @param {number} duration How long to go into flightMode, in minutes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeFlightMode(id: number, duration: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeFlightMode(id, duration, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve configuration for a device
         * @param {number} id device id
         * @param {boolean} [refresh] unused
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetConfig(id: number, refresh?: boolean, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetConfig(id, refresh, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries gatewayReadings of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetGatewayReadings(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetGatewayReadings(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries messages of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetMessages(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetMessages(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get alerts for device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetNotificationTriggers(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetNotificationTriggers(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve points for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetPoints(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetPoints(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve readings for a device
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetReadings(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetReadings(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get safe-zone for device
         * @param {number} id device id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetSafeZone(id: number, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetSafeZone(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries transients of device.
         * @param {number} id device id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeGetTransients(id: number, filter?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeGetTransients(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id device id
         * @param {string} nearbyId
         * @param {string} dateRange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDeviceData(id: number, nearbyId: string, dateRange: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeNearbyDeviceData(id, nearbyId, dateRange, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} id device id
         * @param {string} [dateRange]
         * @param {string} [correlationId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeNearbyDevices(id: number, dateRange?: string, correlationId?: string, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeNearbyDevices(id, dateRange, correlationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update safe-zone for device
         * @param {number} id device id
         * @param {Array<GeoPoint>} data Array of {lat:x,lng:y} points denoting the vertices of the safe-zone
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeSetSafeZone(id: number, data: Array<GeoPoint>, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeSetSafeZone(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for gatewayReadings.
         * @param {number} id device id
         * @param {number} fk Foreign key for gatewayReadings
         * @param {SensorReading} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdGatewayReadings(id: number, fk: number, data?: SensorReading, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeUpdateByIdGatewayReadings(id, fk, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an alert/notification trigger by id {fk} for device
         * @param {number} id device id
         * @param {number} fk Foreign key for notificationTriggers
         * @param {NotificationTrigger} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdNotificationTriggers(id: number, fk: number, data?: NotificationTrigger, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeUpdateByIdNotificationTriggers(id, fk, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for transients.
         * @param {number} id device id
         * @param {number} fk Foreign key for transients
         * @param {DeviceTransient} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateByIdTransients(id: number, fk: number, data?: DeviceTransient, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeUpdateByIdTransients(id, fk, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update configuration for a device
         * @param {number} id device id
         * @param {DeviceConfig} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicePrototypeUpdateConfig(id: number, data?: DeviceConfig, options?: any) {
            return DeviceApiFp(configuration).devicePrototypeUpdateConfig(id, data, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param {string} id Model id
     * @param {string} [filter] Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceFindById(id: string, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).deviceFindById(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new instance in gatewayReadings of this model.
     * @param {number} id device id
     * @param {SensorReading} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeCreateGatewayReadings(id: number, data?: SensorReading, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeCreateGatewayReadings(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new instance in messages of this model.
     * @param {number} id device id
     * @param {DeviceMessage} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeCreateMessages(id: number, data?: DeviceMessage, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeCreateMessages(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create alert/notification trigger for device
     * @param {number} id device id
     * @param {NotificationTrigger} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeCreateNotificationTriggers(id: number, data?: NotificationTrigger, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeCreateNotificationTriggers(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Deletes all gatewayReadings of this model.
     * @param {number} id device id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDeleteGatewayReadings(id: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDeleteGatewayReadings(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Deletes all messages of this model.
     * @param {number} id device id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDeleteMessages(id: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDeleteMessages(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Remove all alert/notification trigger for device
     * @param {number} id device id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDeleteNotificationTriggers(id: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDeleteNotificationTriggers(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a related item by id for gatewayReadings.
     * @param {number} id device id
     * @param {number} fk Foreign key for gatewayReadings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDestroyByIdGatewayReadings(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDestroyByIdGatewayReadings(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Remove alert/notification trigger by id {fk} for device
     * @param {number} id device id
     * @param {number} fk Foreign key for notificationTriggers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDestroyByIdNotificationTriggers(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDestroyByIdNotificationTriggers(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a specific point for a device
     * @param {number} id device id
     * @param {number} fk Foreign key for points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDestroyByIdPoints(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDestroyByIdPoints(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a related item by id for transients.
     * @param {number} id device id
     * @param {number} fk Foreign key for transients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeDestroyByIdTransients(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeDestroyByIdTransients(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a related item by id for gatewayReadings.
     * @param {number} id device id
     * @param {number} fk Foreign key for gatewayReadings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFindByIdGatewayReadings(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFindByIdGatewayReadings(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a related item by id for notificationTriggers.
     * @param {number} id device id
     * @param {number} fk Foreign key for notificationTriggers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFindByIdNotificationTriggers(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFindByIdNotificationTriggers(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve a specific point for a device
     * @param {number} id device id
     * @param {number} fk Foreign key for points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFindByIdPoints(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFindByIdPoints(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve a specific reading for a device
     * @param {number} id device id
     * @param {number} fk Foreign key for readings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFindByIdReadings(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFindByIdReadings(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a related item by id for transients.
     * @param {number} id device id
     * @param {number} fk Foreign key for transients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFindByIdTransients(id: number, fk: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFindByIdTransients(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} id device id
     * @param {number} duration How long to go into flightMode, in minutes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeFlightMode(id: number, duration: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeFlightMode(id, duration, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve configuration for a device
     * @param {number} id device id
     * @param {boolean} [refresh] unused
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetConfig(id: number, refresh?: boolean, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetConfig(id, refresh, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Queries gatewayReadings of device.
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetGatewayReadings(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetGatewayReadings(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Queries messages of device.
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetMessages(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetMessages(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get alerts for device
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetNotificationTriggers(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetNotificationTriggers(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve points for a device
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetPoints(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetPoints(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve readings for a device
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetReadings(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetReadings(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get safe-zone for device
     * @param {number} id device id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetSafeZone(id: number, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetSafeZone(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Queries transients of device.
     * @param {number} id device id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeGetTransients(id: number, filter?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeGetTransients(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} id device id
     * @param {string} nearbyId
     * @param {string} dateRange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeNearbyDeviceData(id: number, nearbyId: string, dateRange: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeNearbyDeviceData(id, nearbyId, dateRange, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} id device id
     * @param {string} [dateRange]
     * @param {string} [correlationId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeNearbyDevices(id: number, dateRange?: string, correlationId?: string, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeNearbyDevices(id, dateRange, correlationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update safe-zone for device
     * @param {number} id device id
     * @param {Array<GeoPoint>} data Array of {lat:x,lng:y} points denoting the vertices of the safe-zone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeSetSafeZone(id: number, data: Array<GeoPoint>, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeSetSafeZone(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a related item by id for gatewayReadings.
     * @param {number} id device id
     * @param {number} fk Foreign key for gatewayReadings
     * @param {SensorReading} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeUpdateByIdGatewayReadings(id: number, fk: number, data?: SensorReading, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeUpdateByIdGatewayReadings(id, fk, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an alert/notification trigger by id {fk} for device
     * @param {number} id device id
     * @param {number} fk Foreign key for notificationTriggers
     * @param {NotificationTrigger} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeUpdateByIdNotificationTriggers(id: number, fk: number, data?: NotificationTrigger, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeUpdateByIdNotificationTriggers(id, fk, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a related item by id for transients.
     * @param {number} id device id
     * @param {number} fk Foreign key for transients
     * @param {DeviceTransient} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeUpdateByIdTransients(id: number, fk: number, data?: DeviceTransient, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeUpdateByIdTransients(id, fk, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update configuration for a device
     * @param {number} id device id
     * @param {DeviceConfig} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public devicePrototypeUpdateConfig(id: number, data?: DeviceConfig, options?: any) {
        return DeviceApiFp(this.configuration).devicePrototypeUpdateConfig(id, data, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Login a user with username/email and password.
         * @param {Credentials} credentials Body (JSON)
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: Credentials, include?: string, options: any = {}): FetchArgs {
            // verify required parameter 'credentials' is not null or undefined
            if (credentials === null || credentials === undefined) {
                throw new RequiredError('credentials', 'Required parameter credentials was null or undefined when calling userLogin.');
            }
            const localVarPath = `/users/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(credentials || {}) : (credentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new instance in geofences of this model.
         * @param {string} id user id
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateGeofences(id: string, data?: Geofence, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeCreateGeofences.');
            }
            const localVarPath = `/users/{id}/geofences`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Geofence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes all geofences of this model.
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteGeofences(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeDeleteGeofences.');
            }
            const localVarPath = `/users/{id}/geofences`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdGeofences(id: string, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeDestroyByIdGeofences.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling userPrototypeDestroyByIdGeofences.');
            }
            const localVarPath = `/users/{id}/geofences/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdGeofences(id: string, fk: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeFindByIdGeofences.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling userPrototypeFindByIdGeofences.');
            }
            const localVarPath = `/users/{id}/geofences/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a summary of all devices on this user account.
         * @param {string} id user id
         * @param {string} [pointCount] Maximum number of points to return per device. Default 5.
         * @param {string} [dateRange] What date range to consider when retrieving recent points. Typical use is [TimeOfLastPointDownload, NOW]. Defaults to all time.
         * @param {string} [hideApprox] Don&#39;t include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDeviceSummary(id: string, pointCount?: string, dateRange?: string, hideApprox?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeGetDeviceSummary.');
            }
            const localVarPath = `/users/{id}/getDeviceSummary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (pointCount !== undefined) {
                localVarQueryParameter['pointCount'] = pointCount;
            }

            if (dateRange !== undefined) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (hideApprox !== undefined) {
                localVarQueryParameter['hideApprox'] = hideApprox;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Queries devices of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevices(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeGetDevices.');
            }
            const localVarPath = `/users/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a list of devices in any given zone or group of zones.
         * @param {string} id user id
         * @param {string} [zoneId] ID of geofence to search. zoneId or zoneType required.
         * @param {string} [zoneType] Type of zones to search. Ignored if zoneId is specified. zoneId or zoneType required.
         * @param {string} [includeApprox] Include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevicesInZone(id: string, zoneId?: string, zoneType?: string, includeApprox?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeGetDevicesInZone.');
            }
            const localVarPath = `/users/{id}/getDevicesInZone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }

            if (zoneType !== undefined) {
                localVarQueryParameter['zoneType'] = zoneType;
            }

            if (includeApprox !== undefined) {
                localVarQueryParameter['includeApprox'] = includeApprox;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Queries geofences of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetGeofences(id: string, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeGetGeofences.');
            }
            const localVarPath = `/users/{id}/geofences`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetMqttCredentials(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeGetMqttCredentials.');
            }
            const localVarPath = `/users/{id}/getMqttCredentials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdGeofences(id: string, fk: number, data?: Geofence, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userPrototypeUpdateByIdGeofences.');
            }
            // verify required parameter 'fk' is not null or undefined
            if (fk === null || fk === undefined) {
                throw new RequiredError('fk', 'Required parameter fk was null or undefined when calling userPrototypeUpdateByIdGeofences.');
            }
            const localVarPath = `/users/{id}/geofences/{fk}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"fk"}}`, encodeURIComponent(String(fk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {"Authorization" : configuration?.accessToken} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = undefined;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Geofence" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(data || {}) : (data || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Login a user with username/email and password.
         * @param {Credentials} credentials Body (JSON)
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: Credentials, include?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userLogin(credentials, include, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new instance in geofences of this model.
         * @param {string} id user id
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateGeofences(id: string, data?: Geofence, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Geofence> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeCreateGeofences(id, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Deletes all geofences of this model.
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteGeofences(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeDeleteGeofences(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdGeofences(id: string, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeDestroyByIdGeofences(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdGeofences(id: string, fk: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Geofence> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeFindByIdGeofences(id, fk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve a summary of all devices on this user account.
         * @param {string} id user id
         * @param {string} [pointCount] Maximum number of points to return per device. Default 5.
         * @param {string} [dateRange] What date range to consider when retrieving recent points. Typical use is [TimeOfLastPointDownload, NOW]. Defaults to all time.
         * @param {string} [hideApprox] Don&#39;t include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDeviceSummary(id: string, pointCount?: string, dateRange?: string, hideApprox?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetDeviceSummary(id, pointCount, dateRange, hideApprox, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Queries devices of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevices(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Device>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetDevices(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve a list of devices in any given zone or group of zones.
         * @param {string} id user id
         * @param {string} [zoneId] ID of geofence to search. zoneId or zoneType required.
         * @param {string} [zoneType] Type of zones to search. Ignored if zoneId is specified. zoneId or zoneType required.
         * @param {string} [includeApprox] Include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevicesInZone(id: string, zoneId?: string, zoneType?: string, includeApprox?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetDevicesInZone(id, zoneId, zoneType, includeApprox, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Queries geofences of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetGeofences(id: string, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Geofence>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetGeofences(id, filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetMqttCredentials(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeGetMqttCredentials(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdGeofences(id: string, fk: number, data?: Geofence, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Geofence> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userPrototypeUpdateByIdGeofences(id, fk, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Login a user with username/email and password.
         * @param {Credentials} credentials Body (JSON)
         * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(credentials: Credentials, include?: string, options?: any) {
            return UserApiFp(configuration).userLogin(credentials, include, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in geofences of this model.
         * @param {string} id user id
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeCreateGeofences(id: string, data?: Geofence, options?: any) {
            return UserApiFp(configuration).userPrototypeCreateGeofences(id, data, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all geofences of this model.
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDeleteGeofences(id: string, options?: any) {
            return UserApiFp(configuration).userPrototypeDeleteGeofences(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeDestroyByIdGeofences(id: string, fk: number, options?: any) {
            return UserApiFp(configuration).userPrototypeDestroyByIdGeofences(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeFindByIdGeofences(id: string, fk: number, options?: any) {
            return UserApiFp(configuration).userPrototypeFindByIdGeofences(id, fk, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve a summary of all devices on this user account.
         * @param {string} id user id
         * @param {string} [pointCount] Maximum number of points to return per device. Default 5.
         * @param {string} [dateRange] What date range to consider when retrieving recent points. Typical use is [TimeOfLastPointDownload, NOW]. Defaults to all time.
         * @param {string} [hideApprox] Don&#39;t include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDeviceSummary(id: string, pointCount?: string, dateRange?: string, hideApprox?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetDeviceSummary(id, pointCount, dateRange, hideApprox, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries devices of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevices(id: string, filter?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetDevices(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve a list of devices in any given zone or group of zones.
         * @param {string} id user id
         * @param {string} [zoneId] ID of geofence to search. zoneId or zoneType required.
         * @param {string} [zoneType] Type of zones to search. Ignored if zoneId is specified. zoneId or zoneType required.
         * @param {string} [includeApprox] Include GSM / poor accuracy locations. Default to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetDevicesInZone(id: string, zoneId?: string, zoneType?: string, includeApprox?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetDevicesInZone(id, zoneId, zoneType, includeApprox, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries geofences of user.
         * @param {string} id user id
         * @param {string} [filter] JSON Filter object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetGeofences(id: string, filter?: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetGeofences(id, filter, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeGetMqttCredentials(id: string, options?: any) {
            return UserApiFp(configuration).userPrototypeGetMqttCredentials(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for geofences.
         * @param {string} id user id
         * @param {number} fk Foreign key for geofences
         * @param {Geofence} [data] Body (JSON)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPrototypeUpdateByIdGeofences(id: string, fk: number, data?: Geofence, options?: any) {
            return UserApiFp(configuration).userPrototypeUpdateByIdGeofences(id, fk, data, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @summary Login a user with username/email and password.
     * @param {Credentials} credentials Body (JSON)
     * @param {string} [include] Related objects to include in the response. See the description of return value for more details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userLogin(credentials: Credentials, include?: string, options?: any) {
        return UserApiFp(this.configuration).userLogin(credentials, include, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new instance in geofences of this model.
     * @param {string} id user id
     * @param {Geofence} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeCreateGeofences(id: string, data?: Geofence, options?: any) {
        return UserApiFp(this.configuration).userPrototypeCreateGeofences(id, data, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Deletes all geofences of this model.
     * @param {string} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeDeleteGeofences(id: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeDeleteGeofences(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a related item by id for geofences.
     * @param {string} id user id
     * @param {number} fk Foreign key for geofences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeDestroyByIdGeofences(id: string, fk: number, options?: any) {
        return UserApiFp(this.configuration).userPrototypeDestroyByIdGeofences(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find a related item by id for geofences.
     * @param {string} id user id
     * @param {number} fk Foreign key for geofences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeFindByIdGeofences(id: string, fk: number, options?: any) {
        return UserApiFp(this.configuration).userPrototypeFindByIdGeofences(id, fk, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve a summary of all devices on this user account.
     * @param {string} id user id
     * @param {string} [pointCount] Maximum number of points to return per device. Default 5.
     * @param {string} [dateRange] What date range to consider when retrieving recent points. Typical use is [TimeOfLastPointDownload, NOW]. Defaults to all time.
     * @param {string} [hideApprox] Don&#39;t include GSM / poor accuracy locations. Default to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetDeviceSummary(id: string, pointCount?: string, dateRange?: string, hideApprox?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetDeviceSummary(id, pointCount, dateRange, hideApprox, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Queries devices of user.
     * @param {string} id user id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetDevices(id: string, filter?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetDevices(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve a list of devices in any given zone or group of zones.
     * @param {string} id user id
     * @param {string} [zoneId] ID of geofence to search. zoneId or zoneType required.
     * @param {string} [zoneType] Type of zones to search. Ignored if zoneId is specified. zoneId or zoneType required.
     * @param {string} [includeApprox] Include GSM / poor accuracy locations. Default to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetDevicesInZone(id: string, zoneId?: string, zoneType?: string, includeApprox?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetDevicesInZone(id, zoneId, zoneType, includeApprox, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Queries geofences of user.
     * @param {string} id user id
     * @param {string} [filter] JSON Filter object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetGeofences(id: string, filter?: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetGeofences(id, filter, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeGetMqttCredentials(id: string, options?: any) {
        return UserApiFp(this.configuration).userPrototypeGetMqttCredentials(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a related item by id for geofences.
     * @param {string} id user id
     * @param {number} fk Foreign key for geofences
     * @param {Geofence} [data] Body (JSON)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPrototypeUpdateByIdGeofences(id: string, fk: number, data?: Geofence, options?: any) {
        return UserApiFp(this.configuration).userPrototypeUpdateByIdGeofences(id, fk, data, options)(this.fetch, this.basePath);
    }

}

